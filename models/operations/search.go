// Code generated by Speakeasy (https://speakeasy.com).

package operations

import (
	"encoding/json"
	"fmt"

	"github.com/dmji/go-redmine/models/components"
)

type Scope string

const (
	ScopeAll         Scope = "all"
	ScopeMyProject   Scope = "my_project"
	ScopeSubprojects Scope = "subprojects"
)

func (e Scope) ToPointer() *Scope {
	return &e
}

func (e *Scope) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "all":
		fallthrough
	case "my_project":
		fallthrough
	case "subprojects":
		*e = Scope(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Scope: %v", v)
	}
}

type AllWords int64

const (
	AllWordsOne AllWords = 1
)

func (e AllWords) ToPointer() *AllWords {
	return &e
}

func (e *AllWords) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		*e = AllWords(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllWords: %v", v)
	}
}

type TitlesOnly int64

const (
	TitlesOnlyOne TitlesOnly = 1
)

func (e TitlesOnly) ToPointer() *TitlesOnly {
	return &e
}

func (e *TitlesOnly) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		*e = TitlesOnly(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TitlesOnly: %v", v)
	}
}

type Issues int64

const (
	IssuesOne Issues = 1
)

func (e Issues) ToPointer() *Issues {
	return &e
}

func (e *Issues) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		*e = Issues(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Issues: %v", v)
	}
}

type QueryParamNews int64

const (
	QueryParamNewsOne QueryParamNews = 1
)

func (e QueryParamNews) ToPointer() *QueryParamNews {
	return &e
}

func (e *QueryParamNews) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		*e = QueryParamNews(v)
		return nil
	default:
		return fmt.Errorf("invalid value for QueryParamNews: %v", v)
	}
}

type WikiPages int64

const (
	WikiPagesOne WikiPages = 1
)

func (e WikiPages) ToPointer() *WikiPages {
	return &e
}

func (e *WikiPages) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		*e = WikiPages(v)
		return nil
	default:
		return fmt.Errorf("invalid value for WikiPages: %v", v)
	}
}

type Projects int64

const (
	ProjectsOne Projects = 1
)

func (e Projects) ToPointer() *Projects {
	return &e
}

func (e *Projects) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		*e = Projects(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Projects: %v", v)
	}
}

type Documents int64

const (
	DocumentsOne Documents = 1
)

func (e Documents) ToPointer() *Documents {
	return &e
}

func (e *Documents) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		*e = Documents(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Documents: %v", v)
	}
}

type Changesets int64

const (
	ChangesetsOne Changesets = 1
)

func (e Changesets) ToPointer() *Changesets {
	return &e
}

func (e *Changesets) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		*e = Changesets(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Changesets: %v", v)
	}
}

type Messages int64

const (
	MessagesOne Messages = 1
)

func (e Messages) ToPointer() *Messages {
	return &e
}

func (e *Messages) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		*e = Messages(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Messages: %v", v)
	}
}

type OpenIssues int64

const (
	OpenIssuesOne OpenIssues = 1
)

func (e OpenIssues) ToPointer() *OpenIssues {
	return &e
}

func (e *OpenIssues) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		*e = OpenIssues(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenIssues: %v", v)
	}
}

type Attachments string

const (
	AttachmentsZero Attachments = "0"
	AttachmentsOne  Attachments = "1"
	AttachmentsOnly Attachments = "only"
)

func (e Attachments) ToPointer() *Attachments {
	return &e
}

func (e *Attachments) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "0":
		fallthrough
	case "1":
		fallthrough
	case "only":
		*e = Attachments(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Attachments: %v", v)
	}
}

type SearchRequest struct {
	Format             components.Format          `pathParam:"style=simple,explode=false,name=format"`
	Limit              *int64                     `queryParam:"style=form,explode=true,name=limit"`
	Offset             *int64                     `queryParam:"style=form,explode=true,name=offset"`
	Nometa             *components.Nometa         `queryParam:"style=form,explode=true,name=nometa"`
	XRedmineSwitchUser *string                    `header:"style=simple,explode=false,name=X-Redmine-Switch-User"`
	XRedmineNometa     *components.XRedmineNometa `header:"style=simple,explode=false,name=X-Redmine-Nometa"`
	Q                  string                     `queryParam:"style=form,explode=true,name=q"`
	Scope              *Scope                     `queryParam:"style=form,explode=true,name=scope"`
	AllWords           *AllWords                  `queryParam:"style=form,explode=true,name=all_words"`
	TitlesOnly         *TitlesOnly                `queryParam:"style=form,explode=true,name=titles_only"`
	Issues             *Issues                    `queryParam:"style=form,explode=true,name=issues"`
	News               *QueryParamNews            `queryParam:"style=form,explode=true,name=news"`
	WikiPages          *WikiPages                 `queryParam:"style=form,explode=true,name=wiki_pages"`
	Projects           *Projects                  `queryParam:"style=form,explode=true,name=projects"`
	Documents          *Documents                 `queryParam:"style=form,explode=true,name=documents"`
	Changesets         *Changesets                `queryParam:"style=form,explode=true,name=changesets"`
	Messages           *Messages                  `queryParam:"style=form,explode=true,name=messages"`
	OpenIssues         *OpenIssues                `queryParam:"style=form,explode=true,name=open_issues"`
	Attachments        *Attachments               `queryParam:"style=form,explode=true,name=attachments"`
}

func (o *SearchRequest) GetFormat() components.Format {
	if o == nil {
		return components.Format("")
	}
	return o.Format
}

func (o *SearchRequest) GetLimit() *int64 {
	if o == nil {
		return nil
	}
	return o.Limit
}

func (o *SearchRequest) GetOffset() *int64 {
	if o == nil {
		return nil
	}
	return o.Offset
}

func (o *SearchRequest) GetNometa() *components.Nometa {
	if o == nil {
		return nil
	}
	return o.Nometa
}

func (o *SearchRequest) GetXRedmineSwitchUser() *string {
	if o == nil {
		return nil
	}
	return o.XRedmineSwitchUser
}

func (o *SearchRequest) GetXRedmineNometa() *components.XRedmineNometa {
	if o == nil {
		return nil
	}
	return o.XRedmineNometa
}

func (o *SearchRequest) GetQ() string {
	if o == nil {
		return ""
	}
	return o.Q
}

func (o *SearchRequest) GetScope() *Scope {
	if o == nil {
		return nil
	}
	return o.Scope
}

func (o *SearchRequest) GetAllWords() *AllWords {
	if o == nil {
		return nil
	}
	return o.AllWords
}

func (o *SearchRequest) GetTitlesOnly() *TitlesOnly {
	if o == nil {
		return nil
	}
	return o.TitlesOnly
}

func (o *SearchRequest) GetIssues() *Issues {
	if o == nil {
		return nil
	}
	return o.Issues
}

func (o *SearchRequest) GetNews() *QueryParamNews {
	if o == nil {
		return nil
	}
	return o.News
}

func (o *SearchRequest) GetWikiPages() *WikiPages {
	if o == nil {
		return nil
	}
	return o.WikiPages
}

func (o *SearchRequest) GetProjects() *Projects {
	if o == nil {
		return nil
	}
	return o.Projects
}

func (o *SearchRequest) GetDocuments() *Documents {
	if o == nil {
		return nil
	}
	return o.Documents
}

func (o *SearchRequest) GetChangesets() *Changesets {
	if o == nil {
		return nil
	}
	return o.Changesets
}

func (o *SearchRequest) GetMessages() *Messages {
	if o == nil {
		return nil
	}
	return o.Messages
}

func (o *SearchRequest) GetOpenIssues() *OpenIssues {
	if o == nil {
		return nil
	}
	return o.OpenIssues
}

func (o *SearchRequest) GetAttachments() *Attachments {
	if o == nil {
		return nil
	}
	return o.Attachments
}

type SearchResponseBody struct {
	Results    []components.Search `json:"results"`
	TotalCount *int64              `json:"total_count,omitempty"`
	Offset     *int64              `json:"offset,omitempty"`
	Limit      *int64              `json:"limit,omitempty"`
}

func (o *SearchResponseBody) GetResults() []components.Search {
	if o == nil {
		return []components.Search{}
	}
	return o.Results
}

func (o *SearchResponseBody) GetTotalCount() *int64 {
	if o == nil {
		return nil
	}
	return o.TotalCount
}

func (o *SearchResponseBody) GetOffset() *int64 {
	if o == nil {
		return nil
	}
	return o.Offset
}

func (o *SearchResponseBody) GetLimit() *int64 {
	if o == nil {
		return nil
	}
	return o.Limit
}

type SearchResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   *SearchResponseBody
}

func (o *SearchResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *SearchResponse) GetObject() *SearchResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
